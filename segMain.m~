function out =segMain(imOrig, configIn)
% Combined morphological-spectral multimodal segmentation
% Segments Image (Im) as a colour image if it is colour RGB image or in
% gray scale only if it is a gray image (one plane only).  
% 
% Inputs -  ImOrig: image to be segmented (should be in range 0-255)
%           configIn.Levels: no. of decomposition levels in the wavelet transform
%               (range: non-zero integers)
%           configIn.t1 and configIn.t2: are usual merging thresholds (range: 0->1)
%           configIn.t3: is the minimum size of region.  
%               if a region is smaller than this, it is merged with a neighbour
%           configIn.hmindepthfactor: controls the amount of the initial segmentation 
%               (range: 0->1)	
%           configIn.merge: perform merging(1) or not(0)
%           configIn.filterNoErode: do not know!
%
% Outputs - out.overlay: final segmentation overlayed on original image
%           out.intoverlay: initial segmentation (before merging) overlayed on 
%               original image
%           out.map: integer segmentation maps after merging (no borders)
%           out.intmap: initial integer segmentation maps before merging
%               (borders=0)
%           out.gsurf: gradient map


%% dimension of registered image set


levels = configIn.levels;
t1 = configIn.t1; t2 = configIn.t2; t3 = configIn.t3;
hminfactor = configIn.hminfactor;
merge = configIn.merge;
filterNoErode = configIn.filterNoErode;

[N, M] = size(imOrig);
imOrig = double(imOrig);
gsurf = zeros(N,M); %initalization of grdient map

global globalmax;
globalmax = zeros(levels.*6); %store max value in each subband for each image


[~,tvold] = dtwavexfm2(double(Im),configIn.dtcwtLevels,'antonini','qshift_06');
%% find gradient map of image
% -------------------------------------------------------------------------
tvol = [];
gsurfpart = zeros(size(imOrig));

tvold = someHighCoefVol;

for n=1:levels
    tvold{n} = abs(tvold{n}(:,:,[1 6 3 4 2 5]));  %rearrange for backward compatibility with older code
    globalmax((n-1)*6+1:n*6) = squeeze(max(max(tvold{n},[],2),[],1))./(2.^n);
end

col = 0; %col=0 for all images; col=1 for CbCr channels; see 'texgradd.m'
[gsurf0,tvolpart] =segprotomm(tvold,double(imOrig), col, filterNoErode); %segment each image
tvol=cat(3,tvol,tvolpart);

clear tvolpart tvold someIm someHighCoefVol;


%% segment and merge
sed = strel('square',3);

intmap = zeros(N,M); %pre-allocation of matrix for speed
map = zeros(N,M); %pre-allocation of matrix for speed

% initial segmentation
gsurf = gsurf0(:,:);
gradmed = median(gsurf(:));
map_t = watershed(imhmin(gsurf,hminfactor*gradmed));
clear gradmed

%shave off nobbly bits in watersheds (trust me, I know what I'm talking
%about)
map2 = zeros(size(map_t));
for k=1:max(map_t(:));
    map2(imclose(map_t==k,sed)) = k;
end;

intmap = map2; %saved for display later

if( merge )
    map = mergestatcombmm(map2,tvol,imorig,t1,t2, t3); %merging regions
else
    map = map2;
end
end


%% To construct overlay and intolay
overlay = uint8(imorig);
intolay = uint8(imorig);

overlayBand = overlay;
overlayBand(map==0) = 255;
overlay = overlayBand;
intolayBand = intolay;
intolayBand(intmap==0) = 255;
intolay = intolayBand;


%% <PUI> I guess this part is for removing region boudaries (map==0).

temp = map;
bw = ones(size(temp));
border = find(temp==0);
bw(border)=0;
[~, ind] = bwdist(bw);
temp(border) = temp(ind(border));
map = temp;


out.intolay = intolay;
out.overlay = overlay;
out.intmap = intmap;
out.map = map;
out.gsurf = gsurf;
